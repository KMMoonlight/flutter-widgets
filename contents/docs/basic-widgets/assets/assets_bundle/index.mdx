---
title: AssetBundle
description: 应用所使用到的资源集合
---

`AssetBundle`是Flutter框架中一个用于从应用程序包内(如图片、配置文件、字体等)或远程位置(通过网络)异步加载资源的抽象类。它并非一个可视化UI组件，而是一个核心的数据访问工具类，是Flutter资源加载体系的基石。其核心逻辑是提供一个统一的、异步的接口来读取各种资源，将资源的物理存储位置(本地、网络)与业务逻辑代码解耦。

### 使用场景
- **加载图片资源**：使用`Image.asset()`时，底层会通过`AssetBundle`来读取图片文件。
- **加载配置文件**：例如读取本地的JSON配置文件(如多语言文件strings.json)来初始化应用设置。
- **加载文本文件**：读取存储在`assets`文件夹下的文本文件，如版权信息、帮助文档等。
- **加载字体文件**：在`pubspec.yaml`中声明字体后，Flutter会通过`AssetBundle`加载它们。
- **网络资源加载(特定实现)**：虽然主要用途是本地资源，但其抽象设计也允许通过网络加载资源，例如`NetworkAssetBundle`。

## 示例
### 1. 基本用法 - 加载文本文件
假设在`pubspec.yaml`中声明了一个文本资源: `assets/docs/copyright.txt`。
```dart
import 'package:flutter/services.dart' show rootBundle; // rootBundle 是默认的 AssetBundle 实例
import 'package:flutter/material.dart';

class CopyrightPage extends StatefulWidget {
  const CopyrightPage({super.key});

  @override
  State<CopyrightPage> createState() => _CopyrightPageState();
}

class _CopyrightPageState extends State<CopyrightPage> {
  String _copyrightText = 'Loading...';

  @override
  void initState() {
    super.initState();
    _loadCopyrightText();
  }

  // 使用 AssetBundle 加载文本
  Future<void> _loadCopyrightText() async {
    try {
      final String loadedText = await rootBundle.loadString('assets/docs/copyright.txt');
      setState(() {
        _copyrightText = loadedText;
      });
    } catch (e) {
      setState(() {
        _copyrightText = 'Failed to load copyright information.';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Copyright')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Text(_copyrightText),
      ),
    );
  }
}
```

### 2. 进阶用法 - 加载并解析JSON配置文件
假设有一个应用配置`assets/config/app_settings.json`
```dart
import 'package:flutter/services.dart' show rootBundle;
import 'dart:convert'; // 使用 dart:convert 来解析JSON

class AppSettings {
  final String appName;
  final int maxRetries;

  AppSettings({required this.appName, required this.maxRetries});

  factory AppSettings.fromJson(Map<String, dynamic> json) {
    return AppSettings(
      appName: json['appName'] as String,
      maxRetries: json['maxRetries'] as int,
    );
  }
}

Future<AppSettings> loadAppSettings() async {
  // 1. 使用 AssetBundle 加载字符串
  final String jsonString = await rootBundle.loadString('assets/config/app_settings.json');
  // 2. 将字符串解析为JSON Map
  final Map<String, dynamic> jsonMap = jsonDecode(jsonString);
  // 3. 将JSON Map转换为Dart对象
  return AppSettings.fromJson(jsonMap);
}

// 在应用初始化时使用
void main() async {
  WidgetsFlutterBinding.ensureInitialized(); // 必须调用，因为在 runApp 之前使用了异步
  final AppSettings settings = await loadAppSettings();
  runApp(MyApp(settings: settings));
}
```

### 3. 加载为字节流并手动处理
```dart
import 'package:flutter/services.dart' show rootBundle;

Future<ByteData> loadImageBytes(String assetPath) async {
  // load 方法返回一个包含资源二进制数据的 ByteData 对象
  final ByteData data = await rootBundle.load(assetPath);
  return data;
}

// 使用示例：将字节数据转换为Uint8List以供其他库使用
void processImage() async {
  ByteData imageData = await loadImageBytes('assets/images/photo.jpg');
  Uint8List bytes = imageData.buffer.asUint8List();
  // 现在可以将 bytes 传递给图像处理库
}
```

## 常见问题和优化技巧
- **资源声明**: 在使用任何资源前，必须在`pubspec.yaml`文件的flutter部分下正确声明资源路径，否则运行时将抛出`Unable to load asset`异常。
```yaml
flutter:
  assets:
    - assets/docs/copyright.txt
    - assets/config/
    - assets/images/
```

- **路径正确性**: `loadString`等方法中使用的路径必须与`pubspec.yaml`中声明的路径完全匹配，区分大小写。
- **异常处理**: 资源加载是异步操作，可能会失败(如文件不存在)。务必使用`try-catch`包裹加载代码，提供优雅的错误处理。
- **性能考量**: 对于较大的资源文件(如大图片、视频)，直接使用`AssetBundle`加载到内存中可能会导致短期内存压力。对于图片，优先使用`Image.asset`，它提供了缓存和分辨率处理等优化。对于大文件，考虑流式处理。
- `rootBundle`与`DefaultAssetBundle`:
  - `rootBundle`: 直接访问应用程序内置的资源包，忽略当前Widget树中可能存在的覆盖。
  - `DefaultAssetBundle`: 是一个Widget，它提供当前上下文中的`AssetBundle`。在开发可复用的组件时，优先使用`DefaultAssetBundle.of(context)`，因为它允许父组件注入一个不同的`AssetBundle`(如在测试中模拟资源)，使代码更具可测试性。

## 构造函数
`AssetBundle`本身是一个抽象类，没有公开的构造函数供开发者直接实例化。我们通常使用它提供的两个主要实例：
1. `rootBundle`:
这是应用程序内置资源的根包。它是一个全局静态实例，类型为`AssetBundle`。

2. 通过`DefaultAssetBundle.of(context)`获取:
这会返回当前Widget在树中所使用的`AssetBundle`。默认情况下，它返回的就是`rootBundle`。

对于特定实现，如`NetworkAssetBundle`，其构造函数如下：
- `NetworkAssetBundle(@NonNull Uri baseUrl)`
  - **描述**:创建一个从指定基URL加载资源的`AssetBundle`。例如，`NetworkAssetBundle(Uri.parse("https://example.com/assets/"))` 会尝试从`https://example.com/assets/path/to/resource`加载资源。


## 属性
由于`AssetBundle`是抽象类，其“属性”主要是它提供的异步加载方法。

| 属性名(方法名) | 返回值类型 | 说明 |
| :--- | :--- | :--- |
| **`load(String key)`** | `Future<ByteData>` | **核心方法**。将资源键名对应的资源加载为一个二进制数据块（`ByteData`）。这是最底层的方法。 |
| **`loadString(String key, { bool cache = true })`** | `Future<String>` | 将资源键名对应的资源以字符串形式加载。`cache` 参数控制是否缓存字符串结果。 |
| **`loadStructuredData<T>(String key, Future<T> parser(String value))`** | `Future<T>` | 一个功能强大的方法。先加载字符串资源，然后使用提供的 `parser` 函数将字符串解析为特定类型 `T` 的对象。示例2中的JSON解析可以简化为使用此方法。 |

**关键属性/方法解释**:
- **loadString**: 这是最常用的方法，用于加载文本、JSON、XML等文本格式的资源。其内部的`cache`机制避免了重复加载的开销，是性能优化的体现。
- `loadStructuredData`: 此方法体现了优秀的API设计，它将“加载”和“解析”两个步骤解耦，并自动处理缓存。当需要将资源文件转换为Dart对象时，这是推荐的最佳实践。例如，加载JSON配置：
```dart
Future<AppSettings> loadSettings() {
  return rootBundle.loadStructuredData<AppSettings>(
    'assets/config/settings.json',
    (String jsonStr) async => AppSettings.fromJson(jsonDecode(jsonStr)),
  );
}
```
