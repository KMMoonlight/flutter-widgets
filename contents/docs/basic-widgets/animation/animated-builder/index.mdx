---
title: AnimatedBuilder
description: 强大动画辅助组件，用于分离动画逻辑和UI构建逻辑
---

`AnimatedBuilder`是Flutter中一个强大的动画辅助组件，属于flutter库的一部分。它主要用于分离动画逻辑和UI构建逻辑，提高代码的可维护性和性能。该组件不直接管理动
画状态，而是作为桥梁，监听动画对象(如`AnimationController`)的变化，并在动画值更新时仅重建指定的子部件部分，从而避免不必要的全局重绘。

### 主要用途: 
- 实现复杂的自定义动画效果，如旋转、缩放或透明度变化。
- 优化动画性能，通过局部重建减少资源消耗。
- 促进代码模块化，将动画逻辑与UI代码解耦。
- 核心逻辑: `AnimatedBuilder`通过`animation`参数监听动画对象，当动画值变化时，自动调用`builder`回调函数来重建`UI`部分，而父部件不会重新构建。这特别适用于大型部件树中仅部分内容需要动画的场景。

### 使用场景: 
- 在列表项中添加淡入淡出动画。
- 创建自定义进度条或加载指示器。
- 实现交互式动画，如按钮点击后的缩放反馈。


## 示例
### 简单旋转动画
```dart
import 'package:flutter/material.dart';

class RotationAnimationExample extends StatefulWidget {
  @override
  _RotationAnimationExampleState createState() => _RotationAnimationExampleState();
}

class _RotationAnimationExampleState extends State<RotationAnimationExample> with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: Duration(seconds: 2),
      vsync: this,
    )..repeat(); // 无限循环动画
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Transform.rotate(
              angle: _controller.value * 2 * 3.14159, // 旋转角度（0到2π弧度）
              child: Icon(Icons.refresh, size: 50),
            );
          },
        ),
      ),
    );
  }
}
```


### 交互式缩放动画
```dart
import 'package:flutter/material.dart';

class ScaleAnimationExample extends StatefulWidget {
  @override
  _ScaleAnimationExampleState createState() => _ScaleAnimationExampleState();
}

class _ScaleAnimationExampleState extends State<ScaleAnimationExample> with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.8).animate(_controller);
  }

  void _onTap() {
    _controller.forward().then((_) => _controller.reverse()); // 点击时先放大再恢复
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: GestureDetector(
          onTap: _onTap,
          child: AnimatedBuilder(
            animation: _scaleAnimation,
            builder: (context, child) {
              return Transform.scale(
                scale: _scaleAnimation.value,
                child: Container(
                  width: 100,
                  height: 50,
                  color: Colors.blue,
                  child: Center(child: Text('点击我', style: TextStyle(color: Colors.white))),
                ),
              );
            },
          ),
        ),
      ),
    );
  }
}
```



### 适配主题的淡入淡出动画
```dart
import 'package:flutter/material.dart';

class ColorAnimationExample extends StatefulWidget {
  @override
  _ColorAnimationExampleState createState() => _ColorAnimationExampleState();
}

class _ColorAnimationExampleState extends State<ColorAnimationExample> with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<Color?> _colorAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: Duration(seconds: 1),
      vsync: this,
    )..repeat(reverse: true); // 往复循环
    _colorAnimation = ColorTween(
      begin: Colors.red,
      end: Colors.blue,
    ).animate(_controller);
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: AnimatedBuilder(
          animation: _colorAnimation,
          builder: (context, child) {
            return Container(
              width: 100,
              height: 100,
              color: _colorAnimation.value,
              child: child, // 重用静态子部件
            );
          },
          child: Icon(Icons.star, color: Colors.white), // 静态部分，避免重复构建
        ),
      ),
    );
  }
}
```


## 注意点
- **常见问题**: 
  - **性能瓶颈**: 如果`builder`回调中包含复杂计算或大量部件，可能导致动画卡顿。建议将静态内容通过`child`参数传递，避免重复构建。
  - **内存泄漏**: 忘记在`dispose()`方法中释放`AnimationController`可能引发内存泄漏。务必在`State`销毁时调用`_controller.dispose()`。
  - **兼容性警告**: `AnimatedBuilder`依赖于`Animation`对象，确保动画在组件挂载后才启动(例如在`initState`中初始化)。

- **优化技巧**: 
  - 使用`child`参数缓存不变的部分，减少重建范围。
  - 对于简单动画，优先考虑隐式动画组件(如`AnimatedContainer`)，以简化代码。
  - 在动画结束时调用`_controller.reverse()`或设置`repeat`模式，实现平滑循环。

- **最佳实践**: 
  - 将动画逻辑封装在独立类或`mixin`中，提高代码可测试性。
  - 在`builder`中避免使用`setState`，以防止无限循环。
  - 测试动画在不同设备上的性能，使用`Flutter DevTools`分析帧率。


## 构造函数
```dart
const AnimatedBuilder({
  Key? key,
  required Listenable animation, // 必选参数，监听的动画对象
  required Widget Function(BuildContext context, Widget? child) builder, // 必选参数，构建UI的回调
  Widget? child, // 可选参数，用于缓存静态子部件
})
```


## 属性
| 属性名       | 属性类型                               | 说明                                                                 |
|--------------|----------------------------------------|----------------------------------------------------------------------|
| `key`        | `Key?`                                 | 组件的键，用于在部件树中识别和控制更新。                             |
| `animation`  | `Listenable`（必需）                   | 被监听的动画对象，如 AnimationController。值变化时触发 builder 调用。 |
| `builder`    | `Widget Function(BuildContext, Widget?)`（必需） | 构建UI的回调函数，接收上下文和可选的 child 参数。                   |
| `child`      | `Widget?`                              | 静态子部件，在动画过程中缓存，避免不必要的重建。                     |



### 关键属性解释: 
- **animation**: 这是核心属性，必须是一个`Listenable`对象(例如`AnimationController`)。它负责驱动动画更新，任何值变化都会导致`builder`重新执行。如果动画未正确初始化或监听，组件将无法响应变化。
- **builder**: 该回调函数决定了动画如何映射到UI。其`child`参数允许重用静态内容，显著提升性能。例如，在示例3中，`Icon`部件通过`child`传递，避免了每次动画更新时的重复构建。
- **child**: 优化性能的关键属性。如果动画仅影响部分UI(如容器的颜色)，将不变的部分作为`child`传入，可减少重建开销。忽略此属性可能导致整个子树重复构建，影响流畅度。
