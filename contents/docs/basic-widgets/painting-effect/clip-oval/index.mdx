---
title: 绘制和效果组件
description: 在不通过修改布局、大小或位置的情况下，对子组件施加虚拟效果的组件
---

`ClipOval`是Flutter的布局组件，用于将子组件裁剪为椭圆形或圆形(当子组件为正方形时)。它通过`CustomClipper<Rect>`实现裁剪逻辑，适用于头像、图标或任何需要圆形/椭圆形UI元素的场景。

- **主要用途**: 将矩形子组件裁剪为椭圆形，提升视觉吸引力。
- **核心逻辑**: 基于子组件的边界框(Bounding Box)计算椭圆路径，超出路径的部分被隐藏。如果子组件宽高相等，裁剪结果为圆形；否则为椭圆形。


### 典型使用场景：
- 用户头像圆形化(如聊天界面、个人资料页)。
- 自定义图标或按钮的圆角效果。
- 配合动画实现动态裁剪(如缩放或旋转)。


## 示例
### 1. 基础圆形头像
```dart
import 'package:flutter/material.dart';
class BasicAvatarExample extends StatelessWidget {
  const BasicAvatarExample({super.key});
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('ClipOval基础示例')),
      body: Center(
        child: ClipOval(
          child: Image.network(
            'https://example.com/avatar.png', // 替换为实际图片URL
            width: 100,
            height: 100,
            fit: BoxFit.cover, // 确保图片填充圆形区域
          ),
        ),
      ),
    );
  }
}
```

### 2. 交互式椭圆按钮
```dart
import 'package:flutter/material.dart';
class InteractiveButtonExample extends StatefulWidget {
  const InteractiveButtonExample({super.key});
  @override
  State<InteractiveButtonExample> createState() => _InteractiveButtonExampleState();
}
class _InteractiveButtonExampleState extends State<InteractiveButtonExample> {
  bool _isPressed = false;
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: GestureDetector(
          onTapDown: (_) => setState(() => _isPressed = true),
          onTapUp: (_) => setState(() => _isPressed = false),
          child: ClipOval(
            child: AnimatedContainer(
              duration: const Duration(milliseconds: 100),
              width: _isPressed ? 120 : 100, // 点击时略微放大
              height: 80, // 宽度≠高度，裁剪为椭圆形
              color: _isPressed ? Colors.blue : Colors.green,
              child: const Icon(Icons.check, color: Colors.white),
            ),
          ),
        ),
      ),
    );
  }
}
```

### 3. 自定义裁剪器(非对称椭圆)
```dart
import 'package:flutter/material.dart';

class CustomClipperExample extends StatelessWidget {
  const CustomClipperExample({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: ClipOval(
          clipper: _AsymmetricClipper(), // 自定义裁剪逻辑
          child: Container(
            width: 200,
            height: 100,
            color: Colors.orange,
            child: const Center(child: Text('非对称椭圆', style: TextStyle(color: Colors.white))),
          ),
        ),
      ),
    );
  }
}

// 自定义Clipper，调整椭圆偏移量
class _AsymmetricClipper extends CustomClipper<Rect> {
  @override
  Rect getClip(Size size) {
    return Rect.fromCenter(
      center: Offset(size.width * 0.6, size.height / 2), // 中心点右移
      width: size.width,
      height: size.height,
    );
  }

  @override
  bool shouldReclip(covariant CustomClipper<Rect> oldClipper) => false;
}
```
**场景说明**: 通过自定义`clipper`参数实现非对称椭圆，演示高级裁剪控制。

## 注意点
- 性能影响: `ClipOval`依赖GPU裁剪，可能增加渲染开销。避免在频繁重绘的组件(如动画列表)中过度使用。若需静态圆形效果，优先使用`CircleAvatar`组件。
- 兼容性警告：在旧版Flutter(<2.0)中，裁剪区域可能受父组件约束影响。确保子组件尺寸明确(如设置`width/height`)，防止裁剪异常。
- 溢出处理：如果子组件内容超出椭圆边界，可能被意外裁剪。通过fit属性(如BoxFit.contain)或调整子组件布局控制显示范围。
- 最佳实践：
  - 为圆形头像添加默认占位符(如`Placeholder`)防止图片加载失败时布局崩溃。
  - 结合`ClipRect`或`ClipPath`实现复杂裁剪效果时，注意裁剪顺序对性能的影响。


## 构造函数
```dart
const ClipOval({
  Key? key,
  CustomClipper<Rect>? clipper, // 自定义裁剪逻辑
  Clip clipBehavior = Clip.antiAlias, // 裁剪行为
  required Widget child, // 被裁剪的子组件
})
```

## 属性
| 属性名         | 属性类型               | 说明                                                                 |
|----------------|------------------------|----------------------------------------------------------------------|
| `clipper`      | `CustomClipper<Rect>?` | 自定义裁剪器。若未设置，使用默认椭圆裁剪逻辑。                       |
| `clipBehavior` | `Clip`                 | 裁剪边缘处理方式，可选值：`Clip.antiAlias`（默认）、`Clip.hardEdge`等。 |
| `child`        | `Widget`               | 被裁剪的子组件，需设置明确尺寸。                                     |


### 关键属性详解：
- **clipBehavior**:
	-  默认值`Clip.antiAlias`能平滑边缘，但轻微影响性能。在需要高性能的场景(如快速滚动列表)，可切换为`Clip.hardEdge`。
- **clipper**:
	-  通过自定义`CustomClipper<Rect>`可实现动态椭圆(如根据手势调整形状)，但需注意在`shouldReclip`中正确管理重绘逻辑，避免不必要的重建。
