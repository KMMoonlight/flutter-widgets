---
title: AppBar
description: 一个Material Design设计的App标题栏
---

`AppBar`由工具栏和其他一些小组件组成，比如`TabBar`和`flexibleSpaceBar`。`AppBar`通常使用`IconButton`来显示一个或者多个常用操作，这些操作后面可选地跟一个`PopupMenuButton`用于不太常见的操作（通常称为"溢出菜单"）。

`AppBar`通常用于`Scaffold.appBar`属性，该属性将`AppBar`作为固定高度的组件放置于屏幕顶部。如果想要可以滚动的`AppBar`可以参考`SliverAppBar`,它将`AppBar`嵌入到了`Sliver`中，以便在`CustomScrollView`中使用。

![](https://flutter.github.io/assets-for-api-docs/assets/material/app_bar.png)

`AppBar`在底部(bottom)上方显示其他的一些组件，如标题、按钮操作等。底部通常用于`TabBar`的使用。如果指定了`flexibleSpace`小组件，则它将堆叠(在Z轴方向上)在工具栏和底部小组件的下面。

如果没有设置`leading`组件，但是`AppBar`位于带有`Drawer`的`Scaffold`中，则会自动在`leading`处添加一个按钮来打开抽屉。如果没有的话，`Navigator`有任何先前的路由，则会在`leading`中插入`BackButton`按钮。可以通过`automaticallyImplyLeading`来关闭此行为。设置为false的时候，中间的组件会向前扩展到空出来的`leading`位置。

> 正常情况下，`AppBar`会根据环境`MediaQuery`的padding来嵌入其内容，以避免干扰系统UI。当使用`Scaffold.appBar`属性时，Scaffold会处理此问题。在为`AppBar`制作动画时，可能会出现意外`MediaQuery`的变化(在Hero动画中很常见)可能会导致内容突然跳动。将`AppBar`包裹在`MediaQuery`小组件中，并调整其填充，使动画流畅。


## 构造函数
```dart
AppBar.new({
    Key? key, 
    Widget? leading, 
    bool automaticallyImplyLeading = true, 
    Widget? title, 
    List<Widget>? actions, 
    Widget? flexibleSpace, 
    PreferredSizeWidget? bottom, 
    double? elevation, 
    double? scrolledUnderElevation, 
    ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate, 
    Color? shadowColor, 
    Color? surfaceTintColor, 
    ShapeBorder? shape, 
    Color? backgroundColor, 
    Color? foregroundColor, 
    IconThemeData? iconTheme, 
    IconThemeData? actionsIconTheme, 
    bool primary = true, 
    bool? centerTitle, 
    bool excludeHeaderSemantics = false, 
    double? titleSpacing, 
    double toolbarOpacity = 1.0, 
    double bottomOpacity = 1.0, 
    double? toolbarHeight, 
    double? leadingWidth, 
    TextStyle? toolbarTextStyle, 
    TextStyle? titleTextStyle, 
    SystemUiOverlayStyle? systemOverlayStyle, 
    bool forceMaterialTransparency = false, 
    bool useDefaultSemanticsOrder = true, 
    Clip? clipBehavior, 
    EdgeInsetsGeometry? actionsPadding, 
    bool animateColor = false
})
```

## 参数
| 参数名   |  参数类型    |  解释   |
|---------|------------|---------|
| actions  | List\<Widget\>? |  在标题后面展示的一个小组件列表 |
| actionsIconTheme |  IconThemeData? | 针对AppBar中的actions设置对应的图标主题信息，包含图标颜色、不透明度和大小等信息|
| actionsPadding | EdgeInsetsGeometry? |  actions和AppBar末端的间距 |
| animateColor | bool | 针对颜色变化是否进行动画 ｜
| automaticllyImplyLeading | bool | 如果leading组件为空时，是否自动添加对应的备选按钮 |
| backgroundColor | Color? | 背景填充色 |
| bottom | PreferredSizeWidget? | 出现在AppBar底部的小组件 |
| bottomOpacity | double | 设置AppBar底部区域的不透明度 |
| centerTitle | bool?   | 标题是否居中 |
| clipBehavior | Clip?  | 根据该选项的内容决定是否对AppBar内容进行裁切 |
| elevation | double? |  AppBar相对于父组件的z坐标(即垂直于屏幕的高度) |
| flexibleSpace | Widget? |  该组件堆叠在tool bar和tab bar后面(即z坐标比这两者更低)。其高度与AppBar的整体高度相同 |
| forceMaterialTransparency | bool | 强制将AppBar的Material小组件类型设置为MaterialType.transparency(而不是Material的默认类型) |
| foregroundColor | Color? | AppBar中文本和图标的默认颜色 |
| hashCode | int | 此对象的哈希码 |
| iconTheme | IconThemeData? |  工具栏图标使用的颜色、不透明度和大小 |
| key | Key? |  |
| leading | Widget? | 在工具栏标题前显示的小组件 |
| leadingWidth | double? | 设置AppBar.leading小组件的宽度 |
| notificationPredicate | ScrollNotificationPredicate |  |
| preferredSize | Size |  工具栏高度与底部小组件高度之和  |
| primary | bool |  设置AppBar是否应该显示在屏幕顶部 |
| runtimeType | Type | 对象运行时类型的表示 |
| scrolledUnderElevation | double? | 如果AppBar下方有滚动内容，则将使用该z轴高度 |
| shadowColor | Color? | AppBar下方阴影的颜色 |
| shape | ShapeBorder? | AppBar材质和阴影的形状 |
| surfaceTintColor | Color? |  应用在AppBar背景色上表面着色层颜色，这样可以凸显出高度 |
| systemOverlayStyle | SystemUiOverlayStyle? | 使用指定的样式来设置在系统Overlay上，比如Android或iOS上的状态栏、Android上的系统导航栏 |
| title | Widget? | AppBar中标题使用的Widget |
| titleSpacing | double? | 标题内容在水平轴上的间距。即使没有leading和actions，也会使用此间距。如果想要标题占用所有可用空间，将此值设置为0.0 |
| titleTextStyle | TextStyle? | AppBar标题小组件所使用的样式 |
| toolbarHeight | double? | 设置AppBar工具栏组件的高度 |
| toolbarOpacity | double | 设置AppBar工具栏组件的不透明度 |
| toolbarTextStyle | TextStyle? | 设置AppBar的文本样式(包含leading和actions，但是不包含标题)  |



## 方法
| 方法名   |  类型    |  解释   |
|---------|------------|---------|
| createElement | () -> StatefulElement |  创建一个StatefulElement来管理此组件在组件树中的位置 |
| createState | () -> State\<AppBar\> | 在组件树中的给定位置为组件创建可变状态 |
| debugDescribeChildren | () -> List\<DiagnosticsNode\> |  返回描述此节点子节点的DiagnosticsNode对象列表 |
| debugFillProperties | (DiagnosticPropertiesBuilder properties) -> void | 添加与节点相关的附加属性  |
| noSuchMethod | (Invocation invocation) -> dynamic |  当访问不存在的方法或属性时调用 |
| toDiagnosticsNode | (\{String? name, DiagnosticsTreeStyle? style\}) -> DiagnosticsNode | 返回一个调试表示形式的对象，该对象由调试工具和DiagnosticsNode.toStringDeep使用。|
| toString | (\{DiagnosticLevel minLevel = DiagnosticLevel.info\}) -> String | 将对象转为字符串 |
| toStringDeep | (\{String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug, int wrapWidth = 65\}) -> String | 将对象以及子节点转为字符串 |
| toStringShallow | (\{String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug\}) -> String |  返回对象的一行详细描述 |
| toStringShort | () -> String |  此组件的简短文本描述  |


## 静态方法
`perferredHeightFor(BuildContext context, Size preferredSize) -> double`

`Scaffold`用它来计算`AppBar`的整体高度。返回值与`preferredSize.height`相同。除非`AppBar.toolbarHeight`为null且`AppBarTheme.of(context).toolbarHeight`非空，在这种情况下，返回值是`AppBar`工具栏高度和`AppBar.bottom`组件高度之和。
