---
title: NestedScrollView
description: 用于处理嵌套滚动的组件
---

`NestedScrollView`是一个特殊的滚动视图组件，专门用于处理嵌套滚动场景。它允许在同一个界面中创建多个可滚动区域，并且能够协调它们之间的滚动行为。当外部滚动视图滚动到顶部时，内部滚动视图可以独立滚动，这种设计常见于具有复杂头部和内容列表的应用界面。

### 核心逻辑
- **协调滚动**: 通过`NestedScrollView`的协调机制，外部和内部滚动视图可以平滑过渡
- **头部固定**: 支持头部区域在滚动时保持固定或折叠效果
- **Sliver组件兼容**: 内部可以使用`Sliver`系列组件实现高级滚动效果

### 使用场景
- 社交应用的动态详情页(头部包含用户信息，下方为评论列表)
- 电商商品详情页(顶部图片轮播，中间商品信息，底部评价列表)
- 新闻阅读应用的详情页面
- 任何需要复杂滚动交互的界面设计


## 示例
### 基础嵌套滚动布局
```dart
import 'package:flutter/material.dart';

class BasicNestedScrollViewExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: NestedScrollView(
        headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) {
          return <Widget>[
            SliverAppBar(
              expandedHeight: 200.0,
              pinned: true,
              flexibleSpace: FlexibleSpaceBar(
                title: Text('NestedScrollView Demo'),
                background: Image.network(
                  'https://picsum.photos/400/200',
                  fit: BoxFit.cover,
                ),
              ),
            ),
          ];
        },
        body: ListView.builder(
          itemCount: 50,
          itemBuilder: (BuildContext context, int index) {
            return ListTile(
              title: Text('Item $index'),
            );
          },
        ),
      ),
    );
  }
}
```

### 带有多重Sliver头部的复杂布局
```dart
import 'package:flutter/material.dart';

class ComplexNestedScrollViewExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: NestedScrollView(
        headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) {
          return <Widget>[
            SliverAppBar(
              expandedHeight: 250.0,
              floating: false,
              pinned: true,
              snap: false,
              flexibleSpace: FlexibleSpaceBar(
                centerTitle: true,
                title: Text(
                  "Complex Example",
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 16.0,
                  ),
                ),
                background: Image.network(
                  'https://picsum.photos/400/250',
                  fit: BoxFit.cover,
                ),
              ),
            ),
            SliverPersistentHeader(
              delegate: _SliverAppBarDelegate(
                TabBar(
                  tabs: [
                    Tab(icon: Icon(Icons.info), text: "Info"),
                    Tab(icon: Icon(Icons.comment), text: "Comments"),
                  ],
                ),
              ),
              pinned: true,
            ),
          ];
        },
        body: TabBarView(
          children: [
            _buildInfoTab(),
            _buildCommentsTab(),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoTab() {
    return ListView.builder(
      physics: NeverScrollableScrollPhysics(),
      itemCount: 20,
      itemBuilder: (BuildContext context, int index) {
        return Card(
          child: ListTile(
            title: Text('Information Item $index'),
          ),
        );
      },
    );
  }

  Widget _buildCommentsTab() {
    return ListView.builder(
      physics: NeverScrollableScrollPhysics(),
      itemCount: 30,
      itemBuilder: (BuildContext context, int index) {
        return ListTile(
          leading: CircleAvatar(
            child: Text('U'),
          ),
          title: Text('User $index'),
          subtitle: Text('This is comment number $index'),
        );
      },
    );
  }
}

class _SliverAppBarDelegate extends SliverPersistentHeaderDelegate {
  final TabBar _tabBar;

  _SliverAppBarDelegate(this._tabBar);

  @override
  Widget build(
      BuildContext context, double shrinkOffset, bool overlapsContent) {
    return Container(
      color: Theme.of(context).scaffoldBackgroundColor,
      child: _tabBar,
    );
  }

  @override
  double get maxExtent => _tabBar.preferredSize.height;

  @override
  double get minExtent => _tabBar.preferredSize.height;

  @override
  bool shouldRebuild(SliverPersistentHeaderDelegate oldDelegate) {
    return false;
  }
}
```

### 自定义滚动行为的交互示例
```dart
import 'package:flutter/material.dart';

class CustomNestedScrollViewExample extends StatefulWidget {
  @override
  _CustomNestedScrollViewExampleState createState() =>
      _CustomNestedScrollViewExampleState();
}

class _CustomNestedScrollViewExampleState
    extends State<CustomNestedScrollViewExample> {
  final ScrollController _scrollController = ScrollController();
  bool _showFloatingButton = true;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(() {
      setState(() {
        _showFloatingButton = _scrollController.offset <= 100;
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      floatingActionButton: _showFloatingButton
          ? FloatingActionButton(
              onPressed: () {
                _scrollController.animateTo(
                  0,
                  duration: Duration(milliseconds: 500),
                  curve: Curves.easeInOut,
                );
              },
              child: Icon(Icons.arrow_upward),
            )
          : null,
      body: NestedScrollView(
        controller: _scrollController,
        headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) {
          return <Widget>[
            SliverAppBar(
              expandedHeight: 300.0,
              floating: true,
              snap: true,
              flexibleSpace: FlexibleSpaceBar(
                title: Text('Custom Scroll Behavior'),
                background: Container(
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [Colors.blue, Colors.purple],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    ),
                  ),
                  child: Center(
                    child: Icon(
                      Icons.star,
                      size: 100,
                      color: Colors.white,
                    ),
                  ),
                ),
              ),
            ),
          ];
        },
        body: CustomScrollView(
          slivers: [
            SliverList(
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  return Container(
                    height: 80,
                    margin: EdgeInsets.symmetric(vertical: 5, horizontal: 10),
                    decoration: BoxDecoration(
                      color: Colors.grey[200],
                      borderRadius: BorderRadius.circular(10),
                    ),
                    child: Center(
                      child: Text(
                        'Custom Item $index',
                        style: TextStyle(fontSize: 18),
                      ),
                    ),
                  );
                },
                childCount: 25,
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }
}
```


## 注意点
### 常见问题
1. 性能瓶颈: 当内部列表包含大量复杂子组件时，可能会影响滚动性能
2. 滚动冲突: 不正确的嵌套可能导致滚动行为异常
3. 内存泄漏: 忘记释放`ScrollController`可能导致内存泄漏
4. 嵌套限制: 不能在`NestedScrollView`内部再嵌套另一个`NestedScrollView` 

### 优化技巧
- 使用`ListView.builder`或`SliverList`进行懒加载，避免一次性构建所有子组件
- 为复杂子组件添加`const`修饰符或使用`RepaintBoundary`
- 合理设置`cacheExtent`属性来控制预加载区域
- 使用`NeverScrollableScrollPhysics()`来禁用不必要的滚动

### 最佳实践
- 始终为`SliverAppBar`设置`pinned`、`floating`或`snap`属性以明确其行为
- 在`TabBarView`中使用`NestedScrollView`时，确保内部列表使用`NeverScrollableScrollPhysics`
- 为不同的滚动区域使用合适的`Sliver`组件
- 测试在不同设备尺寸和方向下的表现


## 构造函数
```dart
NestedScrollView({
  Key? key,
  ScrollController? controller,
  Axis scrollDirection = Axis.vertical,
  bool reverse = false,
  ScrollPhysics? physics,
  required this.headerSliverBuilder,
  required this.body,
  this.dragStartBehavior = DragStartBehavior.start,
  this.floatHeaderSlivers = false,
  this.clipBehavior = Clip.hardEdge,
  this.restorationId,
  this.scrollBehavior,
})
```

## 属性
| 属性名 | 属性类型 | 说明 |
|--------|----------|------|
| controller | ScrollController? | 控制外部滚动视图的控制器 |
| scrollDirection | Axis | 滚动方向（垂直/水平） |
| reverse | bool | 是否反向滚动 |
| physics | ScrollPhysics? | 滚动物理效果配置 |
| headerSliverBuilder | NestedScrollViewHeaderSliversBuilder | 构建头部Sliver组件的回调函数 |
| body | Widget | 主体内容组件 |
| dragStartBehavior | DragStartBehavior | 拖动开始行为配置 |
| floatHeaderSlivers | bool | 控制头部Sliver是否浮动 |
| clipBehavior | Clip | 子组件的裁剪行为 |
| restorationId | String? | 用于状态恢复的标识符 |
| scrollBehavior | ScrollBehavior? | 自定义滚动行为配置 |


### 关键属性详解
**headerSliverBuilder**
- 重要性: 核心属性，必须实现
- 作用: 构建头部区域的`Sliver`组件列表
- 参数: 接收`BuildContext`和`innerBoxIsScrolled`布尔值
- 返回值: 必须返回`Widget`列表

**body**
- 重要性: 核心属性，必须设置
- 限制: 通常应为可滚动组件(`ListView`、`GridView`等)
- 注意事项: 避免在`body`中嵌套另一个`NestedScrollView`

**floatHeaderSlivers**
- 作用: 控制头部`Sliver`在滚动时的行为
- 值为true时: 头部`Sliver`可以浮动显示
- 值为false时: 头部`Sliver`按正常逻辑滚动
- 默认值: false

**controller**
- 用途: 用于编程控制滚动位置
- 注意事项: 需要手动管理生命周期，在`dispose`时释放
- 典型应用: 实现回到顶部、记录滚动位置等功能
